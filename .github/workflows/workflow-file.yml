# ====================================================================================
# GitHub Action Workflow: 自动更新 Cloudflare WAF 规则并部署
# ====================================================================================
#
# 流程描述:
# 1. 定时触发 (或手动触发)。
# 2. 运行 Python 脚本，从 AbuseIPDB 获取最新的恶意 ASN 列表，并更新本地的 `rules.yaml` 文件。
# 3. 检查 `rules.yaml` 是否有变更。如果有，则自动提交 (commit) 并推送 (push) 到 Git 仓库。
# 4. 使用 Terraform 将更新后的 WAF 规则部署到 Cloudflare。
#
# 关键配置:
# - Terraform 状态 (state) 由 Terraform Cloud 远程管理。
# - Terraform 的 plan 和 apply 操作在 GitHub Actions 的 runner 上“本地执行”(Local Execution)。
#   这样做可以避免将 Cloudflare 的 API 密钥存储在 Terraform Cloud 中，增强安全性。
#
# ====================================================================================

name: Auto-update Cloudflare WAF Rules

on:
  # 每天凌晨 3 点 (UTC) 自动运行
  schedule:
    - cron: '0 3 * * *'
  # 允许在 GitHub Actions 页面手动触发此工作流
  workflow_dispatch:

jobs:
  update-and-deploy:
    runs-on: ubuntu-latest
    # 赋予工作流向仓库写入代码的权限，这是 git push 所必需的
    permissions:
      contents: write

    # --------------------------------------------------------------------------------
    # 环境变量 (Secrets)
    # --------------------------------------------------------------------------------
    # 在整个 job 的所有步骤中都可以使用这些环境变量。
    # 请确保已在 GitHub 仓库的 "Settings" -> "Secrets and variables" -> "Actions" 中设置好以下三个 secrets。
    env:
      # 用于 Python 脚本，从 AbuseIPDB 拉取 ASN 黑名单。
      ABUSEIPDB_API_KEY: ${{ secrets.ABUSEIPDB_API_KEY }}
      # 用于 Terraform CLI，登录到 Terraform Cloud 以便管理状态文件。
      TF_API_TOKEN: ${{ secrets.TF_API_TOKEN }}
      # 用于 Terraform Cloudflare Provider，在 GitHub Runner 本地执行时，对 Cloudflare API 进行身份验证。
      CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}

    steps:
      # ==============================================================================
      # 步骤 1: 准备代码和环境
      # ==============================================================================

      # 检出你的 Git 仓库代码到 GitHub Actions 的 runner 环境中
      - name: 1. Checkout Code
        uses: actions/checkout@v4

      # 设置 Python 环境，并安装脚本所需的依赖库 (requests, pyyaml)
      - name: 2. Setup Python and Install Dependencies
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
      - run: |
          python -m pip install --upgrade pip
          pip install requests pyyaml

      # ==============================================================================
      # 步骤 2: 更新 WAF 规则文件
      # ==============================================================================

      # 运行 Python 脚本。脚本会使用 ABUSEIPDB_API_KEY 调用 API，
      # 获取 ASN 列表，然后更新本地工作目录中的 `rules.yaml` 文件。
      - name: 3. Update WAF Rules from AbuseIPDB
        run: python update_abuseipdb_asns.py

      # ==============================================================================
      # 步骤 3: 提交并推送代码变更
      # ==============================================================================

      # 如果 `rules.yaml` 文件被修改了，就将这个变更提交并推送到远程仓库。
      # 这样做可以保持代码库与实际部署的规则同步，方便追踪历史记录。
      - name: 4. Commit and Push WAF Rule Changes
        run: |
          # 配置 git 用户信息，以便进行提交
          git config --local user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

          # 检查 `rules.yaml` 文件是否有未暂存的更改。
          # 如果没有更改，`git status --porcelain` 命令会输出空，脚本就此退出，后续步骤继续执行。
          if [[ -z $(git status --porcelain rules.yaml) ]]; then
            echo "No changes to WAF rules. Skipping commit and push."
          else
            echo "WAF rules changed. Proceeding with commit and push..."
            # 将已修改的 `rules.yaml` 添加到暂存区
            git add rules.yaml
            # 创建一个新的提交
            git commit -m "chore(waf): Auto-update WAF rules with latest ASN list"
            # 拉取远程仓库的最新更改并变基(rebase)，以避免合并冲突，保持提交历史的整洁
            git pull --rebase
            # 将本地的提交推送到远程仓库
            git push
          fi

      # ==============================================================================
      # 步骤 4: 设置并执行 Terraform
      # ==============================================================================

      # 安装指定版本的 Terraform CLI 到 runner 环境中
      - name: 5. Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.6

      # 手动创建 Terraform CLI 的凭证文件 (`.terraformrc`)。
      # `terraform init` 会读取这个文件，找到连接 Terraform Cloud 所需的 API Token。
      # 这是最可靠的 TFC 认证方式，可以避免依赖 `setup-terraform` action 的自动配置。
      - name: 6. Configure Terraform Cloud Credentials
        run: |
          echo 'credentials "app.terraform.io" { token = "${{ env.TF_API_TOKEN }}" }' > ~/.terraformrc

      # 初始化 Terraform。
      # 此命令会下载所需的 provider (如 cloudflare provider)，并根据 `backend` 配置连接到
      # Terraform Cloud，拉取最新的状态文件 (state file)。
      - name: 7. Terraform Init
        run: terraform init

      # (可选维护步骤) 如果 Terraform 状态中存在一个已在 Cloudflare 删除的资源的记录，
      # 这个命令会从状态文件中移除它，以避免后续 `apply` 出错。
      # `|| true` 确保在资源不存在时命令不会失败。
      - name: 8. Remove Stale Resource from State (if it exists)
        run: terraform state rm 'cloudflare_ruleset.waf_ruleset["20241108.xyz"]' || true

      # 执行部署。
      # 因为我们在 Terraform Cloud 工作区中设置了 "Local Execution" 模式，
      # 所以 plan 和 apply 的所有计算和 API 调用都在这个 GitHub Actions runner 上执行。
      # Cloudflare Provider 会自动读取顶层定义的 `CLOUDFLARE_API_TOKEN` 环境变量来完成认证。
      # `-auto-approve` 参数会自动确认应用变更，无需人工交互。
      - name: 9. Terraform Apply
        run: terraform apply -auto-approve
